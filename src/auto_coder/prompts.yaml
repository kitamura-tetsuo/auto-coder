pr:
  action: |-
    You are operating directly in the repository workspace with write access and the git and gh CLIs available.

    Task: For the following GitHub Pull Request, apply safe code changes directly to make it mergeable and passing. Never post PR comments.

    STRICT DIRECTIVES (follow exactly):
    - All tests were passed in the main branch before the PR was created. If the PR is failing tests, it is because of the PR changes. Fix the PR changes. 
    - Do NOT post any comments to the PR, reviews, or issues.
    - Do NOT write narrative explanations as output; take actions in the workspace instead.
    - Prefer targeted edits that make CI pass while preserving intent.
    - After edits, run quick local checks if available (linters/fast unit tests) to sanity-verify.
    - Do NOT run git commit/push; the system will handle committing.
    - If you cannot deterministically fix the PR, stop without posting comments and print only: CANNOT_FIX

    Return format:
    - Print a single line starting with: ACTION_SUMMARY: <brief summary of files changed and whether merged>
    - No greetings, no multi-paragraph analysis.

    Context:
    Repository: $repo_name
    PR #$pr_number: $pr_title

    PR Description (truncated):
    $pr_body...

    PR Author: $pr_author
    PR State: $pr_state
    Draft: $pr_draft
    Mergeable: $pr_mergeable

    PR Changes (first $diff_limit chars):
    $pr_diff

  merge_conflict_resolution: |-
    There are merge conflicts when trying to merge $base_branch branch into PR #$pr_number: $pr_title

    PR Description:
    $pr_body...

    Merge Conflict Information:
    $conflict_info

    Please resolve these merge conflicts by:
    1. Examining the conflicted files
    2. Choosing the appropriate resolution for each conflict
    3. Editing files to fully remove all conflict markers
    4. Do NOT run git add/commit/push; the system will handle committing.

    After resolving the conflicts, respond with a single-line summary of what you resolved.

    Please proceed with resolving these merge conflicts now.

  github_actions_fix: |-
    Fix the following GitHub Actions test failures for PR #$pr_number:

    Repository: $repo_name
    PR Title: $pr_title

    GitHub Actions Error Logs (truncated):
    $github_logs

    Your task:
    1) Identify the root cause(s) of the failing checks based on the logs.
    2) Apply the necessary code changes directly in the repository to fix them.
    3) After applying changes, run the appropriate quick checks if available (linters/unit tests) to sanity-verify.
    4) Do NOT run git commit/push; the system will handle committing and pushing.

    Output requirements:
    - First, provide a concise summary of what you changed and why.
    - Return only a short summary line; no commit/push output is needed.

  local_test_fix: |-
    Fix the following local test failures for PR #$pr_number:

    Repository: $repo_name
    PR Title: $pr_title

    Key Errors:
    $error_summary

    Local test command used:
    $test_command

    Please analyze the test failures and provide specific code fixes.
    Focus on making the tests pass while maintaining code quality.
    All tests were passed in the main branch before the PR was created. If the PR is failing tests, it is because of the PR changes. Fix the PR changes. 

    After analyzing, apply the necessary fixes to the codebase.

  pr_message: |-
    Generate a concise pull request message for the following issue:

    Issue #$issue_number: $issue_title
    Issue Description:
    $issue_body

    Changes Summary:
    $changes_summary

    Requirements:
    - Title: A clear, concise title (max 72 characters) that describes the changes
    - Body: A brief description of what was changed and why (2-3 sentences)
    - Format: Return ONLY the title on the first line, followed by a blank line, then the body
    - Do NOT include any markdown formatting, headers, or extra text

    Example format:
    Fix authentication bug in login flow

    Updated the authentication logic to properly handle edge cases when users
    have special characters in their passwords. This resolves the login failures
    reported in the issue.

issue:
  action: |-
    Analyze the following GitHub issue and take appropriate actions:

    Repository: $repo_name
    Issue #$issue_number: $issue_title

    Issue Description:
    $issue_body...

    Issue Labels: $issue_labels
    Issue State: $issue_state
    Created by: $issue_author

    Please analyze this issue and determine the appropriate action:

    1. If this needs clarification, add a comment requesting more information
    2. If this is a duplicate or invalid issue (spam, unclear, already resolved, etc.), close it with an appropriate comment
    3. If this is a valid issue but need to more than about 30 file changes, break this down into multiple smaller sub issues via gh cli.
    4. If this is a valid bug report or feature request, provide analysis and implementation

    For valid issue but need to more than about 30 file changes:
    - Break down the issue into multiple smaller sub issues
    - Create multiple smaller sub issues via gh.
      example: gh sub-issue create --parent $issue_number --title $title --body $body
    - Keep open the issue

    For valid issues that can be implemented:
    - Analyze the requirements
    - Implement the necessary code changes
    - Create or modify files as needed
    - Ensure the implementation follows best practices
    - Prefer the smart, reasonable and logically beautiful change that resolves issues.
    - Keep open the issue
    - All tests were passed in the main branch. If tests are failing, it is because of the changes.

    For duplicate/invalid issues:
    - Close the issue
    - Add a polite comment explaining why it was closed

    After taking action, respond with a summary of what you did.

    Please proceed with analyzing and taking action on this issue now.

tests:
  workspace_fix: |-
    You are operating directly in this repository workspace with write access.

    Goal: Make local tests pass by applying safe edits.

    Task Memory File: ./llm_task.md
    - If the file exists, review the "Logging Protocol" section before making changes.
    - After completing your attempt, insert a new entry at the top of "## Experiment Log" using this exact template:
    ```
    ### YYYY-MM-DD HH:MM (local)
    - Change Summary:
    - Expected Outcome:
    - Tests Run: `bash scripts/test.sh ...`
    - Actual Outcome:
    - Variance Analysis:
    - Follow-ups / Notes:
    ```
    - Keep earlier log entries intact and maintain the newest entry first ordering.

    STRICT RULES:
    - Do NOT run git commit/push; the system will handle that.
    - Prefer the smart, reasonable and logically beautiful change that resolves failures and preserves intent.

    Local Test Failure Summary (truncated):
    $error_summary

     Local test command used:
     $test_command

    Now apply the fix directly in the repository.
    Run tests again after applying the fix to verify that the fix resolves the issue.
    Return a single concise line summarizing the change.

  test_stability_fix: |-
    You are operating directly in this repository workspace with write access.

    Goal: Fix test stability and dependency issues.

    PROBLEM DETECTED:
    A test file failed when run as part of the full test suite, but passed when run in isolation.
    This indicates one of the following issues:
    1. Test isolation problem: Tests are not properly cleaning up after themselves
    2. Test order dependency: Tests depend on execution order or state from other tests
    3. Shared state: Tests are sharing mutable state (global variables, class attributes, etc.)
    4. Resource conflicts: Tests are competing for shared resources (files, ports, database connections, etc.)
    5. Timing issues: Race conditions or timing-dependent behavior

    Test File: $test_file

    Full Test Suite Output (FAILED):
    $full_suite_output

    Isolated Test Output (PASSED):
    $isolated_test_output

    Task Memory File: ./llm_task.md
    - If the file exists, review the "Logging Protocol" section before making changes.
    - After completing your attempt, insert a new entry at the top of "## Experiment Log" using this exact template:
    ```
    ### YYYY-MM-DD HH:MM (local)
    - Change Summary:
    - Expected Outcome:
    - Tests Run: `bash scripts/test.sh ...`
    - Actual Outcome:
    - Variance Analysis:
    - Follow-ups / Notes:
    ```
    - Keep earlier log entries intact and maintain the newest entry first ordering.

    STRICT RULES:
    - Do NOT run git commit/push; the system will handle that.
    - Focus on fixing test isolation, removing dependencies between tests, and ensuring proper cleanup
    - Consider using pytest fixtures with proper scope (function, class, module, session)
    - Ensure tests clean up any resources they create (files, database records, etc.)
    - Avoid relying on test execution order
    - Use mocking/patching appropriately to isolate tests from external dependencies

    Now apply the fix directly in the repository.
    Run the full test suite again after applying the fix to verify that the fix resolves the issue.
    Return a single concise line summarizing the change.

  commit_message: |-
    You are an expert code reviewer and commit message generator.

    Before writing the commit message, **first review the changes** by running:
    * `git diff` to inspect unstaged changes
    * `git diff --cached` to inspect staged changes

    Then, analyze the diff and write a high-quality Git commit message following these rules:

    1. **Message Format**:
      * Use the [Conventional Commits](https://www.conventionalcommits.org/) style:
        `<type>(<scope>): <summary>`
      * Examples of `<type>`: `feat`, `fix`, `refactor`, `chore`, `test`, `docs`, `style`, `perf`
      * `<scope>` should reflect the primary affected module, package, or feature.
      * `<summary>` must be imperative, concise (<72 chars), and describe *what the change does*, not *what you did*.

    2. **Body (Optional but Recommended)**:
      * Include 1–3 bullet points explaining **what** changed and **why**.
      * Mention key implementation details, reasoning, or side effects.
      * If the change fixes a bug or issue, briefly describe the cause and resolution.

    3. **Footer (Optional)**:
      * Add references like `Fixes #123` or `Refs #456` if applicable.

    4. **General Principles**:
      * Do not restate the diff or list every modified file.
      * Avoid vague terms like "update code" or "fix some bugs."
      * Prefer precise and descriptive language, e.g.,
        * ✅ `fix(yjs): prevent null dereference in observer`
        * ✅ `perf(search): optimize indexing for large trees`

    5. **Output Format**:
      * Provide the final commit message **ready to use**, including summary, body, and footer if necessary.
      * Do **not** include explanations of your reasoning.
      * Wrap the entire commit message in triple backticks (```) before and after.


gemini:
  pr_analysis: |-
    Analyze the following GitHub pull request and provide a structured analysis:

    Title: $title
    Body: $body
    Labels: $labels
    Branch: $head_branch -> $base_branch
    Changes: +$additions -$deletions files: $changed_files
    Draft: $draft
    Mergeable: $mergeable

    Please provide analysis in the following JSON format:
    {
        "category": "bugfix|feature|refactor|documentation|test",
        "risk_level": "low|medium|high",
        "review_priority": "low|medium|high",
        "estimated_review_time": "minutes|hours",
        "recommendations": [
            {
                "action": "description of recommended action",
                "rationale": "why this action is recommended"
            }
        ],
        "potential_issues": ["issue1", "issue2"],
        "summary": "brief summary of the changes"
    }

feature:
  suggestion: |-
    Based on the following repository context, suggest new features that would be valuable:

    Repository: $repo_name
    Description: $description
    Language: $language
    Recent Issues: $recent_issues
    Recent PRs: $recent_prs

    Please provide feature suggestions in the following JSON format:
    [
        {
            "title": "Feature title",
            "description": "Detailed description of the feature",
            "rationale": "Why this feature would be valuable",
            "priority": "low|medium|high",
            "complexity": "simple|moderate|complex",
            "estimated_effort": "hours|days|weeks",
            "labels": ["enhancement", "feature"],
            "acceptance_criteria": [
                "criteria 1",
                "criteria 2"
            ]
        }
    ]

mcp:
  # GraphRAG MCP server usage guidelines (CUSTOMIZED FORK)
  # This is a customized fork of rileylemm/graphrag_mcp for TypeScript/JavaScript code analysis
  # Located at: mcp/graphrag_mcp/
  # The MCP server provides tools dynamically via MCP protocol

  usage_guidelines: |-
    GraphRAG MCP provides code analysis tools for TypeScript/JavaScript codebases.
    Code structure is indexed using ts-morph and stored in Neo4j (graph) + Qdrant (vectors).

    Available Tools:

    1. find_symbol(fqname):
       - Find a specific symbol by fully qualified name
       - Example: find_symbol("src/utils.ts::calculateHash")
       - Returns: id, kind, signature, complexity, location, etc.

    2. get_call_graph(symbol_id, direction='both', depth=1):
       - Analyze function/method call relationships
       - direction: 'callers' | 'callees' | 'both'
       - depth: 1-3 (higher = more indirect relationships)
       - Returns: nodes (related symbols) and edges (call relationships)

    3. get_dependencies(file_path):
       - Analyze file import relationships
       - Example: get_dependencies("src/utils.ts")
       - Returns: imports (what this file imports) and imported_by (who imports this)

    4. impact_analysis(symbol_ids, max_depth=2):
       - Analyze impact of changing symbols
       - Finds all affected symbols via CALLS/IMPORTS/EXTENDS/IMPLEMENTS
       - Returns: affected_symbols, affected_files, impact_summary

    5. semantic_code_search(query, limit=10, kind_filter=None):
       - Search code using natural language
       - Example: semantic_code_search("hash calculation functions", kind_filter=["Function"])
       - Returns: semantically similar symbols with scores

    Graph Schema (ts-morph):
    - Nodes: File, Function, Method, Class, Interface, Type
    - Edges: CONTAINS, CALLS, EXTENDS, IMPLEMENTS, IMPORTS
    - Properties: id, kind, fqname, sig, complexity, file, start_line, end_line, tags

    Best Practices:
    - Use find_symbol when you know the exact symbol name
    - Use semantic_code_search when exploring unfamiliar code
    - Use get_call_graph to understand function relationships
    - Use impact_analysis before making changes to assess scope
    - Use get_dependencies to understand module structure

    MCP Resources:
    - https://graphrag.db/schema/neo4j - Detailed Neo4j schema with node/edge definitions
    - https://graphrag.db/collection/qdrant - Qdrant vector collection info (embeddings)
